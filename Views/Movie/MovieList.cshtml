@model IEnumerable<MovieTheater.ViewModels.MovieViewModel>
@{
    ViewData["Title"] = "Movie List";
    var allTypes = ViewBag.AllTypes as List<MovieTheater.Models.Type>;
    var allVersions = ViewBag.AllVersions as List<MovieTheater.Models.Version>;
    var selectedTypeIds = ViewBag.SelectedTypeIds as List<int> ?? new List<int>();
    var selectedVersionIds = ViewBag.SelectedVersionIds as List<int> ?? new List<int>();
}

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet" />
<link href="~/css/movie-grid.css" rel="stylesheet" />

<div id="content">
    <div id="movieFilterAndGrid" class="movie-filter-and-grid-margin">
        @await Html.PartialAsync("_MovieFilterAndGrid", Model)
    </div>
</div>

<partial name="_ToastMessages" />

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.cycle2/2.1.6/jquery.cycle2.min.js"></script>
    <script>
        let selectedTypeIds = @Html.Raw(Newtonsoft.Json.JsonConvert.SerializeObject(selectedTypeIds));
        let selectedVersionIds = @Html.Raw(Newtonsoft.Json.JsonConvert.SerializeObject(selectedVersionIds));

        function bindFilterEvents() {
            // Chips
            document.getElementById('typeChips').addEventListener('click', function (e) {
                const chip = e.target.closest('.chip');
                if (!chip) return;
                const id = parseInt(chip.getAttribute('data-typeid'));
                if (isNaN(id)) return;
                
                if (chip.classList.contains('selected')) {
                    // If already selected, deselect it
                    selectedTypeIds = selectedTypeIds.filter(tid => tid !== id);
                } else {
                    // If not selected, select it
                    selectedTypeIds.push(id);
                }
                updateFilter();
            });
            document.getElementById('versionChips').addEventListener('click', function (e) {
                const chip = e.target.closest('.chip');
                if (!chip) return;
                const id = parseInt(chip.getAttribute('data-versionid'));
                if (isNaN(id)) return;
                
                if (chip.classList.contains('selected')) {
                    // If already selected, deselect it
                    selectedVersionIds = selectedVersionIds.filter(vid => vid !== id);
                } else {
                    // If not selected, select it
                    selectedVersionIds.push(id);
                }
                updateFilter();
            });
            // Search
            const searchInput = document.getElementById('searchInput');
            let timeoutId;
            searchInput.addEventListener('input', function () {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    updateFilter();
                }, 300);
            });
        }



        function updateFilter() {
            const params = new URLSearchParams();
            if (selectedTypeIds.length > 0) params.append('typeIds', selectedTypeIds.join(','));
            if (selectedVersionIds.length > 0) params.append('versionIds', selectedVersionIds.join(','));
            const searchInput = document.getElementById('searchInput');
            const searchValue = searchInput ? searchInput.value : '';
            const searchFocused = searchInput === document.activeElement;
            const searchCursorPosition = searchInput ? searchInput.selectionStart : 0;
            
            if (searchValue) params.append('searchTerm', searchValue);

            const newUrl = window.location.pathname + '?' + params.toString();
            window.history.pushState({ path: newUrl }, '', newUrl);

            fetch(`/Movie/MovieList?${params.toString()}`, {
                headers: { "X-Requested-With": "XMLHttpRequest" }
            })
            .then(response => response.text())
            .then(html => {
                document.getElementById("movieFilterAndGrid").innerHTML = html;
                
                // Restore search input state
                const newSearchInput = document.getElementById('searchInput');
                if (newSearchInput && searchValue) {
                    newSearchInput.value = searchValue;
                    if (searchFocused) {
                        newSearchInput.focus();
                        newSearchInput.setSelectionRange(searchCursorPosition, searchCursorPosition);
                    }
                }
                
                bindFilterEvents(); // Re-bind after AJAX update
            });
        }

        // Initial binding
        bindFilterEvents();
    </script>
}
