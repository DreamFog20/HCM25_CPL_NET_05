@model MovieTheater.ViewModels.MovieDetailViewModel
@using System.Security.Claims
@{
    ViewData["Title"] = "Movie Show Schedule";
    var userRole = User.FindFirst(ClaimTypes.Role)?.Value;
}
<link rel="stylesheet" href="~/css/schedule.css" asp-append-version="true" />

<div class="container schedule-form-container mt-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        @if (userRole == "Admin")
        {
            <a asp-controller="Admin" asp-action="MainPage" asp-route-tab="MovieMg" class="btn btn-outline-secondary">
                &larr; Return
            </a>
        }
        else
        {
            <a asp-controller="Employee" asp-action="MainPage" asp-route-tab="MovieMg" class="btn btn-outline-secondary">
                &larr; Return
            </a>
        }
    </div>

    <h2 class="schedule-page-title mb-0 text-center" style="font-size: xx-large">Movie Schedule</h2>

    <div class="movie-info mb-4" style="font-size: large">
        <p class="text-muted mb-1">
            <span class="fw-bold">Movie ID:</span> @Model.MovieId
        </p>
        <p class="text-muted mb-1">
            <span class="fw-bold">Movie Name:</span> @Model.MovieNameEnglish
        </p>
         <p class="text-muted mb-1">
            <span class="fw-bold">Duration:</span> @Model.Duration minutes
        </p>
        <input type="hidden" id="movieDuration" value="@Model.Duration" />
         <p class="text-muted mb-1">
            <strong>Version: </strong>
            @foreach (var version in Model.AvailableVersions)
            {
                <label class="me-3">
                    <input type="radio"
                           name="SelectedVersionIds"
                           value="@version.VersionId"
                           @(Model.SelectedVersionIds.Contains(version.VersionId) ? "checked" : "")
                           class="version-radio" />
                    @version.VersionName
                </label>
            }
            <span asp-validation-for="SelectedVersionIds" class="text-danger"></span>
        </p>
    </div>

    <div class="schedule-form">
        <input type="hidden" id="movieId" value="@Model.MovieId" />
        <div id="validationSummary" class="text-danger"></div>

        <!-- Cinema Room Selection -->
        <div class="form-group mb-4">
            <label for="cinemaRoomSelect" class="section-title">Cinema Room</label>
            <select class="form-control" id="cinemaRoomSelect">
                <option value="">-- Select a Cinema Room --</option>
                @foreach (var room in Model.AvailableCinemaRooms)
                {
                    <option value="@room.CinemaRoomId">@room.CinemaRoomName</option>
                }
            </select>
            <span class="text-danger" id="cinemaRoomError"></span>
        </div>

        <!-- Show Dates -->
        <div class="form-group mb-4">
            <label class="section-title">Show Date</label>
            <select class="form-control" id="showDateSelect">
                <option value="">-- Select a Show Date --</option>
                @{
                    var today = DateOnly.FromDateTime(DateTime.Today);
                    var toDate = Model.ToDate;
                    foreach (var showDate in Model.AvailableShowDates.OrderBy(d => d))
                    {
                        if (showDate >= today && (toDate == null || showDate <= toDate))
                        {
                            <option value="@showDate.ToString("yyyy-MM-dd")">@showDate.ToString("dd/MM/yyyy")</option>
                        }
                    }
                }
            </select>
            <span class="text-danger" id="showDateError"></span>
        </div>

        <!-- Schedules -->
        <div class="form-group mb-4">
            <label class="section-title">Available Schedules</label>
            <div id="lastShowEndTime" class="text-muted" style="font-size: 0.9em; margin-bottom: 5px;"></div>
            <select class="form-control" id="scheduleSelect">
                @foreach (var schedule in Model.AvailableSchedules)
                {
                    <option value="@schedule.ScheduleId">@schedule.ScheduleTime</option>
                }
            </select>
            <span class="text-danger" id="scheduleError"></span>
        </div>

        <!-- Movie Show List -->
        <div class="form-group">
            <label class="section-title">Current Movie Shows</label>
            <div id="movieShowsContainer" class="mt-3 p-2 bg-light rounded border">
                <!-- Movie shows will be rendered here by JavaScript -->
            </div>

            <div class="text-center">
                <button type="button" class="btn btn-outline-primary mt-3 mb-3" id="addMovieShowBtn" disabled>
                    Add Movie Show
                </button>
            </div>
        </div>
        <div class="text-center">
            <button type="button" class="btn btn-primary mb-3" id="saveChangesBtn">
                Save Changes
            </button>
        </div>
    </div>
</div>

<partial name="_ToastMessages" />

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const cinemaRoomSelect = document.getElementById('cinemaRoomSelect');
        const showDateSelect = document.getElementById('showDateSelect');
        const scheduleSelect = document.getElementById('scheduleSelect');
        const addMovieShowBtn = document.getElementById('addMovieShowBtn');
        const movieShowsContainer = document.getElementById('movieShowsContainer');
        const saveChangesBtn = document.getElementById('saveChangesBtn');
        const movieId = document.getElementById('movieId').value;
        const movieDuration = parseInt(document.getElementById('movieDuration').value, 10);
        const cleaningTime = 15; // You can change this value as needed
        const lastShowEndTimeEl = document.getElementById('lastShowEndTime');
        
        let movieShowItems = @Html.Raw(Json.Serialize(Model.CurrentMovieShows.Select(show => new {
            dateId = show.ShowDate.ToString("yyyy-MM-dd"),
            dateText = show.ShowDate.ToString("dd/MM/yyyy"),
            roomId = show.CinemaRoomId,
            roomName = show.CinemaRoom?.CinemaRoomName ?? "N/A",
            scheduleId = show.ScheduleId,
            scheduleText = show.Schedule?.ScheduleTime?.ToString("HH:mm") ?? "N/A",
            versionId = show.VersionId,
            versionName = show.Version?.VersionName,
            cinemaRoomVersionName = show.CinemaRoom?.Version?.VersionName,
            version = show.Version?.VersionName ?? (show.CinemaRoom?.Version?.VersionName ?? "N/A")
        })));

        async function updateAvailableSchedules() {
            const selectedRoom = cinemaRoomSelect.value;
            const selectedDate = showDateSelect.value;

            if (!selectedRoom || !selectedDate) {
                scheduleSelect.innerHTML = '<option value="">-- Select a Schedule --</option>';
                return;
            }

            // 1. Fetch backend schedules and shows
            const response = await fetch(`/Movie/GetAvailableScheduleTimes?cinemaRoomId=${selectedRoom}&showDate=${selectedDate}&movieDurationMinutes=${movieDuration}&cleaningTimeMinutes=${cleaningTime}`);
            const result = await response.json();
            const availableSchedules = result.schedules;

            // 2. Fetch backend shows for this room/date
            let backendShows = [];
            try {
                const resp = await fetch(`/Movie/GetMovieShowsByRoomAndDate?cinemaRoomId=${selectedRoom}&showDate=${selectedDate}`);
                if (resp.ok) {
                    backendShows = await resp.json();
                }
            } catch (e) {
                console.error('Failed to fetch backend shows', e);
            }

            // 3. Get UI shows for this room/date
            const uiShows = movieShowItems.filter(item => item.roomId === selectedRoom && item.dateId === selectedDate);

            // 4. Merge shows
            const allShows = [...backendShows, ...uiShows];

            // 5. Filter available schedules to hide conflicts
            const filteredSchedules = availableSchedules.filter(schedule => {
                return !isScheduleConflicting(schedule.scheduleTime, allShows, movieDuration, cleaningTime);
            });

            // 6. Update dropdown
            scheduleSelect.innerHTML = '<option value="">-- Select a Schedule --</option>';
            filteredSchedules.forEach(schedule => {
                const option = document.createElement('option');
                option.value = schedule.scheduleId;
                option.textContent = schedule.scheduleTime;
                scheduleSelect.appendChild(option);
            });

            // 7. Update next available time hint
            if (allShows.length > 0) {
                // Find latest end time
                let latestEnd = null;
                for (const show of allShows) {
                    if (!show.scheduleText) continue;
                    const [startHour, startMin] = show.scheduleText.split(':').map(Number);
                    const start = new Date(0, 0, 0, startHour, startMin);
                    const end = new Date(start.getTime() + (movieDuration + cleaningTime) * 60000);
                    if (!latestEnd || end > latestEnd) latestEnd = end;
                }
                if (latestEnd) {
                    const h = latestEnd.getHours().toString().padStart(2, '0');
                    const m = latestEnd.getMinutes().toString().padStart(2, '0');
                    lastShowEndTimeEl.textContent = `This cinema is available at: ${h}:${m} (+ ${cleaningTime} mins cleaning)`;
                    if (filteredSchedules.length > 0) {
                        lastShowEndTimeEl.textContent += ` - Next available time: ${filteredSchedules[0].scheduleTime}`;
                    }
                }
            } else {
                lastShowEndTimeEl.textContent = 'No shows scheduled for this room and date yet.';
            }
        }

        function updateAddButtonState() {
            const hasRoom = cinemaRoomSelect.value !== '';
            const hasDate = showDateSelect.value !== '';
            const hasSchedule = scheduleSelect.value !== '';
            addMovieShowBtn.disabled = !(hasRoom && hasDate && hasSchedule);
        }

        cinemaRoomSelect.addEventListener('change', async function() {
            await updateAvailableSchedules();
            updateAddButtonState();
        });

        showDateSelect.addEventListener('change', async function() {
            await updateAvailableSchedules();
            updateAddButtonState();
        });

        scheduleSelect.addEventListener('change', updateAddButtonState);

        addMovieShowBtn.addEventListener('click', addMovieShow);

        renderMovieShows();

        function renderMovieShows() {
            movieShowsContainer.innerHTML = '';
            
            movieShowItems.sort((a, b) => {
                const dateComparison = a.dateId.localeCompare(b.dateId);
                if (dateComparison !== 0) return dateComparison;
                const roomComparison = a.roomName.localeCompare(b.roomName);
                if (roomComparison !== 0) return roomComparison;
                return a.scheduleText.localeCompare(b.scheduleText);
            });

            const indexedMovieShowItems = movieShowItems.map((item, index) => ({ ...item, originalIndex: index }));

            const groupedByDate = indexedMovieShowItems.reduce((acc, show) => {
                if (!acc[show.dateId]) {
                    acc[show.dateId] = [];
                }
                acc[show.dateId].push(show);
                return acc;
            }, {});

            Object.keys(groupedByDate).sort().forEach(dateId => {
                const showsForDate = groupedByDate[dateId];
                const dateText = new Date(dateId).toLocaleDateString('en-GB');

                const dateContainer = document.createElement('div');
                dateContainer.className = 'date-group mb-4 p-3 border rounded';
                
                const dateHeader = document.createElement('h5');
                dateHeader.className = 'date-header mb-3 border-bottom pb-2';
                dateHeader.textContent = `Date: ${dateText}`;
                dateContainer.appendChild(dateHeader);

                showsForDate.forEach(show => {
                    const showDiv = document.createElement('div');
                    showDiv.className = 'movie-show-entry alert alert-light d-flex justify-content-between align-items-center mb-2';
                    
                    let endTimeText = '';
                    if (show.scheduleText && show.scheduleText !== 'N/A' && movieDuration) {
                        const [hours, minutes] = show.scheduleText.split(':').map(Number);
                        const startTime = new Date();
                        startTime.setHours(hours, minutes, 0, 0);
                        
                        const endTime = new Date(startTime.getTime() + movieDuration * 60000);
                        
                        const endHours = endTime.getHours().toString().padStart(2, '0');
                        const endMinutes = endTime.getMinutes().toString().padStart(2, '0');
                        endTimeText = ` ~ ${endHours}:${endMinutes}`;
                    }

                    const contentDiv = document.createElement('div');
                    contentDiv.innerHTML = `
                        <span class="fw-bold me-2">Room:</span><span>${show.roomName}</span>
                        <span class="fw-bold ms-3 me-2">Time:</span><span>[${show.scheduleText}${endTimeText}]</span>
                        <span class="fw-bold ms-3 me-2">Version:</span><span>${show.version}</span>
                    `;

                    const removeButton = document.createElement('button');
                    removeButton.type = 'button';
                    removeButton.className = 'btn btn-outline-danger btn-sm';
                    removeButton.innerHTML = 'Remove';
                    removeButton.onclick = function() {
                        removeMovieShow(show.originalIndex);
                    };

                    showDiv.appendChild(contentDiv);
                    showDiv.appendChild(removeButton);
                    dateContainer.appendChild(showDiv);
                });

                movieShowsContainer.appendChild(dateContainer);
            });
        }

        async function addMovieShow() {
            const selectedDateId = showDateSelect.value;
            const selectedDateText = showDateSelect.options[showDateSelect.selectedIndex].text;
            const selectedScheduleId = scheduleSelect.value;
            const selectedScheduleText = scheduleSelect.options[scheduleSelect.selectedIndex].text;

            const roomId = cinemaRoomSelect.value;
            const roomName = cinemaRoomSelect.options[cinemaRoomSelect.selectedIndex].text;

            // Get the selected version ID from the radio button
            const selectedVersionRadio = document.querySelector('input[name="SelectedVersionIds"]:checked');
            const versionId = selectedVersionRadio ? parseInt(selectedVersionRadio.value) : null;
            const versionName = selectedVersionRadio ? selectedVersionRadio.parentElement.textContent.trim() : "N/A";

            // Build the new show object
            const movieShowItem = {
                dateId: selectedDateId,
                dateText: selectedDateText,
                scheduleId: selectedScheduleId,
                scheduleText: selectedScheduleText,
                roomId: roomId,
                roomName: roomName,
                versionId: versionId,
                version: versionName
            };

            // --- Call checkAndSuggest before adding ---
            const allShowsForRoomDate = await getMergedShowsForRoomDate(roomId, selectedDateId);

            if (isTimeConflict(movieShowItem, allShowsForRoomDate, movieDuration, cleaningTime)) {
                alert('This schedule conflicts with another show in this room and date.');
                return;
            }

            movieShowItems.push(movieShowItem);
            renderMovieShows();
            scheduleSelect.innerHTML = '<option value="">-- Select a Schedule --</option>';

            await updateAvailableSchedules();

            updateAddButtonState();
        }

        function removeMovieShow(index) {
            movieShowItems.splice(index, 1);
            renderMovieShows();
        }

        saveChangesBtn.addEventListener('click', async function() {
            if (movieShowItems.length === 0) {
                alert('Please add at least one movie show before saving.');
                return;
            }

            try {
                // 1. Fetch current shows from backend (get all for this movie)
                const resp = await fetch(`/Movie/ViewShow/${movieId}`, {
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                });
                const backendShows = await resp.json();

                // 2. Find shows to delete (in backend but not in UI)
                const showsToDelete = backendShows.filter(b =>
                    !movieShowItems.some(u =>
                        u.dateId === b.showDate.split('/').reverse().join('-') &&
                        u.roomId == b.cinemaRoomId &&
                        u.scheduleId == b.scheduleId &&
                        u.versionId == b.versionId
                    )
                );

                // 3. Find shows to add (in UI but not in backend)
                const showsToAdd = movieShowItems.filter(u =>
                    !backendShows.some(b =>
                        u.dateId === b.showDate.split('/').reverse().join('-') &&
                        u.roomId == b.cinemaRoomId &&
                        u.scheduleId == b.scheduleId &&
                        u.versionId == b.versionId
                    )
                );

                // 4. Try to delete shows (one by one, safely)
                let undeletableShows = [];
                for (const show of showsToDelete) {
                    const delResp = await fetch('/Movie/DeleteMovieShowIfNotReferenced', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(show.movieShowId)
                    });
                    const delResult = await delResp.json();
                    if (!delResult.success) {
                        undeletableShows.push(show);
                    }
                }

                // 5. Add new shows
                for (const showItem of showsToAdd) {
                    const response = await fetch('/Movie/AddMovieShow', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            movieId: movieId,
                            showDate: showItem.dateId,
                            scheduleId: showItem.scheduleId,
                            cinemaRoomId: showItem.roomId,
                            versionId: showItem.versionId
                        })
                    });
                    if (!response.ok) {
                        throw new Error(`Failed to add movie show for schedule ${showItem.scheduleText}`);
                    }
                }

                if (undeletableShows.length > 0) {
                    alert('Some shows could not be deleted because they are referenced by invoices.');
                } else {
                    alert('Movie shows saved successfully!');
                }
                window.location.reload();
            } catch (error) {
                console.error('Error saving movie shows:', error);
                alert('An error occurred while saving the movie shows. Please try again.');
            }
        });

        const versionRadios = document.querySelectorAll('.version-radio');
        versionRadios.forEach(radio => {
            radio.addEventListener('change', async function() {
                const versionId = this.value;
                const response = await fetch(`/Cinema/GetRoomsByVersion?versionId=${versionId}`);
                if (response.ok) {
                    const rooms = await response.json();
                    cinemaRoomSelect.innerHTML = '<option value="">-- Select a Cinema Room --</option>';
                    rooms.forEach(room => {
                        const option = document.createElement('option');
                        option.value = room.cinemaRoomId;
                        option.textContent = room.cinemaRoomName;
                        cinemaRoomSelect.appendChild(option);
                    });
                } else {
                    cinemaRoomSelect.innerHTML = '<option value="">-- No rooms available --</option>';
                }
            });
        });

        async function getMergedShowsForRoomDate(roomId, dateId) {
            // 1. Fetch backend shows
            let backendShows = [];
            try {
                const resp = await fetch(`/Movie/GetMovieShowsByRoomAndDate?cinemaRoomId=${roomId}&showDate=${dateId}`);
                if (resp.ok) {
                    backendShows = await resp.json();
                }
            } catch (e) {
                console.error('Failed to fetch backend shows', e);
            }

            // 2. Get UI shows
            const uiShows = movieShowItems.filter(item => item.roomId === roomId && item.dateId === dateId);

            // 3. Merge (avoid duplicates if needed)
            // If you want to avoid duplicate scheduleText, you can filter here
            const allShows = [...backendShows, ...uiShows];

            return allShows;
        }

        function getNextAvailableTime(allShows, movieDuration, cleaningTime) {
            // allShows: array of shows for the room/date, each with a scheduleText (e.g., "14:00")
            // Returns a string like "15:30" or null if no shows

            if (!allShows || allShows.length === 0) return null;

            // Sort by scheduleText (time)
            allShows.sort((a, b) => a.scheduleText.localeCompare(b.scheduleText));

            // Find the latest end time
            let latestEnd = null;
            for (const show of allShows) {
                if (!show.scheduleText) continue;
                const [startHour, startMin] = show.scheduleText.split(':').map(Number);
                const start = new Date(0, 0, 0, startHour, startMin);
                const end = new Date(start.getTime() + (movieDuration + cleaningTime) * 60000);
                if (!latestEnd || end > latestEnd) latestEnd = end;
            }

            // Format as HH:mm
            if (latestEnd) {
                const h = latestEnd.getHours().toString().padStart(2, '0');
                const m = latestEnd.getMinutes().toString().padStart(2, '0');
                return `${h}:${m}`;
            }
            return null;
        }

        async function checkAndSuggest(roomId, dateId, newScheduleText) {
            const allShows = await getMergedShowsForRoomDate(roomId, dateId);

            // Conflict check
            if (allShows.some(show => show.scheduleText === newScheduleText)) {
                alert('This schedule conflicts with another show in this room and date.');
                return false;
            }

            // Next available time
            const nextTime = getNextAvailableTime(allShows, movieDuration, cleaningTime);
            if (nextTime) {
                lastShowEndTimeEl.textContent = `Next available time: ${nextTime}`;
            } else {
                lastShowEndTimeEl.textContent = 'No shows scheduled for this room and date yet.';
            }
            return true;
        }

        function isTimeConflict(newShow, allShows, movieDuration, cleaningTime) {
            // Parse new show's start and end time
            const [newStartHour, newStartMin] = newShow.scheduleText.split(':').map(Number);
            const newStart = new Date(0, 0, 0, newStartHour, newStartMin);
            const newEnd = new Date(newStart.getTime() + (movieDuration + cleaningTime) * 60000);

            for (const show of allShows) {
                if (!show.scheduleText) continue;
                const [showStartHour, showStartMin] = show.scheduleText.split(':').map(Number);
                const showStart = new Date(0, 0, 0, showStartHour, showStartMin);
                const showEnd = new Date(showStart.getTime() + (movieDuration + cleaningTime) * 60000);

                // Check for overlap
                if (newStart < showEnd && newEnd > showStart) {
                    return true; // There is a conflict
                }
            }
            return false; // No conflict
        }

        function isScheduleConflicting(scheduleTime, allShows, movieDuration, cleaningTime) {
            const [newStartHour, newStartMin] = scheduleTime.split(':').map(Number);
            const newStart = new Date(0, 0, 0, newStartHour, newStartMin);
            const newEnd = new Date(newStart.getTime() + (movieDuration + cleaningTime) * 60000);

            for (const show of allShows) {
                if (!show.scheduleText) continue;
                const [showStartHour, showStartMin] = show.scheduleText.split(':').map(Number);
                const showStart = new Date(0, 0, 0, showStartHour, showStartMin);
                const showEnd = new Date(showStart.getTime() + (movieDuration + cleaningTime) * 60000);

                if (newStart < showEnd && newEnd > showStart) {
                    return true;
                }
            }
            return false;
        }
    });
</script>
